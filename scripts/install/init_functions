#!/bin/sh

export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin:/usr/local/bin"
export BOOT_DEVICE=""
export BOOT_MODE=""

log_info() {
    echo "[*] $1" >&2
}
log_error() {
    echo "[ERR*] $1" >&2
}
log_sys() {
    logger -p user.info "[*] $1"
}

load_mod () {
    for mod in "$@"; do
        modprobe "$mod" || true
    done
}

do_init_hostname() {
    if [ -n "$hostname" ]; then
        hostname "$hostname"
    elif [ -f /mnt/boot_from/hostname ]; then
        hostname -F /mnt/boot_from/hostname
    elif [ -f /etc/hostname ]; then
        hostname -F /etc/hostname
    else
        # Fallback if the file doesn't exist for some reason
        hostname "zpod-default"
    fi
}

do_reboot() {
  mountpoint -q "/mnt/boot_from" && (umount /mnt/boot_from || true)
  mountpoint -q "/mnt/boot" && (umount /mnt/boot || true)
  mountpoint -q "/mnt/root" && (umount /mnt/root || true)

  if [ "$BOOT_MODE" = "iso" ]; then
    sync && (eject /dev/sr0 ;eject /dev/cdrom ; eject -s /dev/sr0 ; eject -s /dev/cdrom) || true
  fi

  sync
  reboot
}

do_try_dhcp() {
    ip link set eth0 up || true
    udhcpc -bqS -A 10 &> /dev/null
}

do_start_network() {
    # 如果应用配置失败, 则尝试dhcp
    do_apply_network_config || do_try_dhcp
}

do_init_prepare() {
    [ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

    mount -t proc -o noexec,nosuid,nodev proc /proc
    mount -t sysfs -o noexec,nosuid,nodev sysfs /sys    
    mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev 2>/dev/null || mount -t tmpfs -o exec,nosuid,mode=0755,size=2M tmpfs /dev
    [ -c /dev/kmsg ] || mknod -m 660 /dev/kmsg c 1 11

    mkdir -p /sys/firmware/efi/efivars || true
    mount -t efivarfs -o noexec,nosuid,nodev efivarfs /sys/firmware/efi/efivars &> /dev/null || true

    set -- $(cat /proc/cmdline)
}

do_init_rootfs_prepare() {
    if [ -f "/proc/sys/kernel/hotplug" ]; then
      echo /sbin/mdev > /proc/sys/kernel/hotplug || true
    fi
    
    /sbin/mdev -d

    mkdir -p /dev/shm  || true
    mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm || true
    mount -t tmpfs -o nodev,nosuid,exec tmpfs /tmp || true
    mount -t tmpfs -o nodev,nosuid,exec tmpfs /var || true
    mount -t tmpfs -o nodev,nosuid,exec tmpfs /run || true

    [ -c /dev/null ] || mknod -m 666 /dev/null c 1 3 &> /dev/null || true
    [ -c /dev/kmsg ] || mknod -m 660 /dev/kmsg c 1 11 &> /dev/null || true
    [ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 2 &> /dev/null || true
    mknod -m 622 /dev/console c 5 1 &> /dev/null || true
    mknod -m 666 /dev/zero c 1 5 &> /dev/null || true
    mknod -m 666 /dev/tty c 5 0 &> /dev/null || true
    mknod -m 444 /dev/random c 1 8 &> /dev/null || true
    mknod -m 444 /dev/urandom c 1 9 &> /dev/null || true

    mkdir -m 755 /dev/pts
    mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts

    #cgroup v2
    # cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1

    mkdir -p /var/lock
    chmod 1777 /var/lock
    mkdir -p /var/log
    mkdir -p /var/run
    mkdir -p /var/state
    mkdir -p /var/tmp
    mkdir -p /mnt/boot_from
    mkdir -p /mnt/boot
    mkdir -p /mnt/root

    touch /var/log/wtmp
    touch /var/log/lastlog

    mkdir -p /tmp/resolv.conf.d
    touch /tmp/resolv.conf.d/resolv.conf.auto
    ln -sf /tmp/resolv.conf.d/resolv.conf.auto /tmp/resolv.conf.auto
    ln -sf /tmp/resolv.conf.d/resolv.conf.auto /tmp/resolv.conf

    grep -q debugfs /proc/filesystems && /bin/mount -o noatime -t debugfs debugfs /sys/kernel/debug
    grep -q pstore /proc/filesystems && /bin/mount -o noatime -t pstore pstore /sys/fs/pstore
    grep -q bpf /proc/filesystems && /bin/mount -o nosuid,nodev,noexec,noatime,mode=0700 -t bpf bpffs /sys/fs/bpf
}

do_find_label_part() {
    local label="$1"
    local disk="$2"

    if [ -z "$disk" ]; then
        blkid | grep "$label" | awk '{print $1}' | cut -d : -f 1 | head -n 1
    else
        blkid | grep "$label" | grep "$disk" | awk '{print $1}' | cut -d : -f 1 | head -n 1
    fi
}

do_find_boot_part() {
    log_info "Scanning for boot device..."

    ISO_PART=$(do_find_label_part ZPOD_INSTALL)
    if [ -n "$ISO_PART" ]; then
        BOOT_DEVICE="${ISO_PART}"
        BOOT_MODE="iso"

        mount -o ro "${BOOT_DEVICE}" /mnt/boot_from || true
        log_info "Found ISO boot device: ${BOOT_DEVICE}"
        return
    fi

    # 遍历所有可能的块设备 (sda, sdb, sr0, nvme0n1, etc.)
    for device in /sys/class/block/*; do
        DEVICE_NAME=$(basename "$device")
        
        # 使用 blkid 读取设备的标签，-p 使用底层探测，更可靠
        MATCHES=$(blkid -p "/dev/${DEVICE_NAME}" -s LABEL -o value | grep ZPOD_INSTALL | wc -l)
        if [ $MATCHES -eq 1 ]; then
            BOOT_DEVICE="/dev/${DEVICE_NAME}"
            BOOT_MODE="iso"

            mount -o ro "${BOOT_DEVICE}" /mnt/boot_from || true

            log_info "Found ISO boot device: ${BOOT_DEVICE}"
            break # 找到就退出循环
        fi

        # 注意：分区设备名可能是 sda1, sdb2, nvme0n1p2
        # 我们需要探测分区
        if ls "/sys/class/block/${DEVICE_NAME}"/*/partition >/dev/null 2>&1; then
            for partition in "/dev/${DEVICE_NAME}"*; do
                # 确保它是一个块设备文件
                if [ -b "$partition" ]; then
                    MATCHES=$(blkid -p "$partition" -s LABEL -o value | grep ZPOD_BOOT | wc -l)
                    if [ $MATCHES -eq 1 ]; then
                        BOOT_DEVICE="$partition"
                        BOOT_MODE="disk"

                        # vmware 25h2, disk is nvme
                        mount "$BOOT_DEVICE" /mnt/boot_from || true

                        log_info "Found Disk boot partition: ${BOOT_DEVICE}"
                        return # 找到就退出内外两层循环
                    else
                        # 尝试挂载, 并检查文件
                        mount "$partition" /mnt/boot_from >/dev/null 2>&1 || true

                        if [ -e "/mnt/boot_from/boot/disk.img.gz" ] && [ -e "/mnt/boot_from/boot/zpod-vmlinuz" ]; then
                            BOOT_DEVICE="$partition"
                            BOOT_MODE="disk"

                            log_info "Found Disk boot partition: ${BOOT_DEVICE}"
                            return # 找到就退出内外两层循环
                        fi

                        mountpoint -q "/mnt/boot_from" && (umount /mnt/boot_from >/dev/null 2>&1 || true)
                    fi
                fi
            done
        fi
    done
}

do_backup_boot() {
    mkdir -p /tmp/backup/boot || true
    cp -rf /mnt/boot_from/boot/* /tmp/backup/boot || true

    mountpoint -q "/mnt/boot_from" && (umount /mnt/boot_from || true)
    ln -s /tmp/backup/boot /mnt/boot_from/boot || true
}

do_backup_src() {
    src="$1"
    dst="$2"

    #如果源分区是在目标磁盘, 则需要先将源分区的boot文件 复制出来
    (echo "$src" | grep "$dst") && (do_backup_boot || true)
}

do_refresh_part() {
    ROOT_DISK="$1"
    
    partprobe "$ROOT_DISK" || true
    sleep 1
}

do_install_and_reboot() {
    ROOT_DISK="$1"
    do_refresh_part "$ROOT_DISK"

    log_info "Start preparing files ${ROOT_DISK}..."

    BOOT_PART=$(do_find_label_part "ZPOD_BOOT" "${ROOT_DISK}")
    ROOT_PART=$(do_find_label_part "ZPOD_ROOT" "${ROOT_DISK}")
    if [ -z "$BOOT_PART" ] || [ -z "$ROOT_PART" ]; then
        echo "$BOOT_PART or $ROOT_PART not found..."
        return
    fi

    # 1. 扩容root分区 resize part4(root),  1: EFI 2: BIOS 3: BOOT 4: ROOT
    #parted -f -s "${ROOT_DISK}" resizepart 4 100%
    growpart "${ROOT_DISK}" 4
    do_refresh_part "$ROOT_DISK"

    #e2fsck -vpf "${ROOT_PART}"
    #do_refresh_part $ROOT_DISK
    #resize2fs -f "${ROOT_PART}"
    #do_refresh_part $ROOT_DISK

    # 这里存在一个bug, https://github.com/tytso/e2fsprogs/issues/98
    # 如果实际容量 大于 之前的配置的 1000 倍, 会报错, 所以不如直接重新格式化
    mkfs.ext4 -L ZPOD_ROOT -F "${ROOT_PART}"

    # 2. copy conf to boot, copy os bin to boot row
    mount "${BOOT_PART}" /mnt/boot || true
    mount "${ROOT_PART}" /mnt/root || true

    # 复用grub文件
    mkdir -p /mnt/boot/boot/grub || true
    cp -rf /mnt/boot_from/boot/grub/* /mnt/boot/boot/grub || true

    # 复制 vmlinuz 和 initrd, 以及如果存在以zpod开头的文件
    cp -f /mnt/boot_from/boot/zpod* /mnt/boot/boot || true

    # 复制一份配置文件, 使其可写
    cp -f /mnt/boot_from/boot/*.conf /mnt/root/ || true

    # 重新获取root分区的uuid, 生成 grub.cfg
    ROOT_UUID=$(blkid | grep "${ROOT_PART}" | awk '{print $3}' | sed 's/UUID=//g' | sed 's/"//g')
    cat > "/mnt/boot/boot/grub/grub.cfg" << EOF
set timeout=3
set default=0

menuentry "ZPod OS" {
    echo "Loading ZPod Kernel..."
    linux /boot/zpod-vmlinuz root=UUID=${ROOT_UUID} mitigations=off selinux=0 net.ifnames=0 biosdevname=0 rmode=zpod ro quiet cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory swapaccount=1
    initrd /boot/zpod-initrd
}
EOF

    log_info "Install Okay, wait reboot..."
}

do_find_and_rename_interface() {
    local target_iface_name="$1"
    local target_mac="$2"
    
    log_sys "Searching for interface with MAC address: ${target_mac} to ${target_iface_name}..."

    # Normalize target MAC to lowercase for reliable comparison
    target_mac=$(echo "$target_mac" | tr '[:upper:]' '[:lower:]')

    # Iterate through all available network interfaces in /sys/class/net
    for iface in /sys/class/net/*; do
        # Skip loopback and non-physical interfaces
        [ -d "$iface/device" ] || continue
        
        current_iface_name=$(basename "$iface")
        current_mac=$(cat "${iface}/address")

        if [ "$current_mac" = "$target_mac" ]; then
            log_sys "Found matching interface: ${current_iface_name}"
            # Check if it already has the correct name
            if [ "$current_iface_name" != "$target_iface_name" ]; then
                log_sys "Renaming ${current_iface_name} to ${target_iface_name}..."
                # Interface must be down to be renamed
                ip link set dev "$current_iface_name" down
                ip link set dev "$current_iface_name" name "$target_iface_name"
            else
                log_sys "Interface already has the correct name."
            fi
            
            # Return the final interface name
            echo "$target_iface_name"
            return 0
        fi
    done

    log_sys "No network interface found with MAC address ${target_mac}!"
    return 1
}

do_apply_network_config() {    
    # 尝试通过 source 加载配置文件, 进而初始化环境变量
    if [ -e /mnt/boot/zpod_config.conf ]; then
      . /mnt/boot/zpod_config.conf
    fi

    if [ -e /mnt/root/zpod_config.conf ]; then
      . /mnt/root/zpod_config.conf
    fi

    if [ -e /data/zpod_config.conf ]; then
      . /data/zpod_config.conf
    fi

    #配置主机名, 启动 syslogd
    if [ -z "$hostname" ]; then
      hostname='zpod'
    fi
    hostname "$hostname"        

    syslogd -O /var/log/messages -s 512 -b 2 -l 7

    # 应用网络配置
    if [ -z "$interface" ]; then
      log_sys "interface $interface not set in conf" 
      return 1
    fi

    case "$interface" in
        *@*)
            # It's in the format "name@mac"
            TARGET_IFACE_NAME=${interface%@*}
            TARGET_MAC=${interface#*@}
            FINAL_IFACE_NAME=$(do_find_and_rename_interface "$TARGET_IFACE_NAME" "$TARGET_MAC")
            ;;
        *)
            # It's just a name, use it directly
            FINAL_IFACE_NAME="$interface"
            log_sys "Using predefined interface name: ${FINAL_IFACE_NAME}"
            ;;
    esac

    if [ -z "$FINAL_IFACE_NAME" ]; then
        log_sys "Could not determine final interface. Attempting DHCP..."
        return 1
    fi

    log_sys "Ethernet ${FINAL_IFACE_NAME} try set ipv4 to ${ipv4_address}"

    ip link set dev "${FINAL_IFACE_NAME}" up || true
    ip addr flush dev "${FINAL_IFACE_NAME}" || true

    if [ -n "$ipv4_address" ]; then
        ip addr add "${ipv4_address}" dev "${FINAL_IFACE_NAME}"
    else
        log_sys "No IPv4 address provided. Attempting DHCP..."
        return 1
    fi

    if [ -n "$ipv4_gateway" ]; then
        log_sys "Setting default IPv4 gateway: ${ipv4_gateway}"
        ip route del default >/dev/null 2>&1 || true
        ip route add default via "${ipv4_gateway}" dev "${FINAL_IFACE_NAME}"
    fi

    echo "nameserver 1.1.1.1" > /etc/resolv.conf
    if [ -n "$dns_servers" ]; then
        log_sys "Configuring DNS servers $dns_servers ..."        
        for server in $dns_servers; do
            echo "nameserver ${server}" >> /etc/resolv.conf
        done
    fi

    # If using DHCP, resolv.conf is usually handled by the DHCP client hook scripts.
}


do_boot_normal() {
    # prepare zpod agent openrc

    # use busybox init
    load_mod sr_mod nvme ahci ext4 overlay fuse

    # mount root to /data  
    for param in $(cat /proc/cmdline); do
        case "$param" in
            root=*)
                ROOT_DEVICE="${param#root=}" 
                log_info "Zpod find root part ${ROOT_DEVICE} to /data"
                mkdir /data || true
                mount -o "defaults,noatime,nodiratime" "${ROOT_DEVICE}" /data
                ;;
            ro)
                # 发现了只读标记
                MOUNT_OPTS="ro"
                ;;
        esac
    done

    # 应用优化配置, 启动ntp时间同步, 根据 /etc/fstab 挂载
    do_start_network
    sysctl -pq &> /dev/null
    # 网络就绪前不执行ntp.  
    ntpd -d -q &> /dev/null

    [ ! -d /var/lib ] && (mkdir -p /var/lib || true)
    [ ! -d /data/containerd ] && (mkdir -p /data/containerd || true)
    [ ! -d /var/lib/containerd ] && (ln -s /data/containerd /var/lib/containerd || true)

    [ ! -d /data/containers ] && (mkdir -p /data/containers || true)
    [ ! -d /var/lib/containers ] && (ln -s /data/containers /var/lib/containers || true)

    [ ! -d /data/root ] && (mkdir -p /data/root || true)

    [ ! -f /data/root/.ash_history ] && ( touch /data/root/.ash_history || true )
    ln -s /data/root/.ash_history /root/.ash_history || true

    [ ! -f /data/root/commands.log ] && ( touch /data/root/commands.log || true )
    ln -s /data/root/commands.log /var/log/commands.log || true

    # 配置欢迎语    
    IP_ADDR=$(ip addr | grep "scope global" | awk '{print $2}')
    echo '[*] Welcome to Zpod Container' > /etc/issue
    echo "[*] Kernel \r on \m (\l) IP: ${IP_ADDR}" >> /etc/issue

    uptime  |             awk '{printf("[*] CPU Load: %.2f, %.2f, %.2f\n", $(NF-2),$(NF-1),$(NF))}' > /etc/motd
    free -m |        awk 'NR==2{printf("[*] Mem     : %sMB/%sMB %.2f%%\n", $3,$2,$3*100/$2)}'       >> /etc/motd
    df -h   | awk '$NF=="/data"{printf "[*] Disk Use: %s/%s %s\n", $3,$2,$5}'                       >> /etc/motd

    exec /sbin/init
}